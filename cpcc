#!/usr/bin/env python

# This file is part of Copernicus
# http://www.copernicus-computing.org/
# 
# Copyright (C) 2011, Sander Pronk, Iman Pouya, Erik Lindahl, and others.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published 
# by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.



# This is the main executable, from which all actions are launched. 

import sys
import copy

import cpc.util
from cpc.util import cmd_line_utils
from cpc.util.conf.connection_bundle import ConnectionBundle

from cpc.client.view.cmdline import CmdLine
from cpc.network.com.client_base import ClientError
from cpc.client import ClientMessage
from cpc.network.com.client_response import ProcessedResponse
import subprocess


def print_usage():
    print "Usage: cpcc [global-options] <command> [command-options]"
    print 
    print "Project start & stop commands:"
    print "       cpcc projects|p"
    print "       cpcc start          projectname"
    print "       cpcc remove|rm      projectname"
    print "       cpcc set-default|d  projectname"
    print "       cpcc get-default    projectname"
    print 
    print "Project query commands."
    print "       cpcc list|ls     [-p projectname] [instance_name]"
    print "       cpcc get         [-p projectname] inst:in|out.ioname"
    print "       cpcc getf        [-p projectname] [-f filename] inst:in|out.ioname "
    print "       cpcc info        [-p projectname] function_name|module_name"
    print "       cpcc log         [-p projectname] instance_name"
    print 
    print "Project manipulation commands."
    print "       cpcc import      [-p projectname] modulename"
    print "       cpcc instance    [-p projectname] function_name instance_name"
    print "       cpcc activate    [-p projectname] [item]"
    print "       cpcc deactivate  [-p projectname] [item]"
    print "       cpcc connect     [-p projectname] inst:out.item inst:in.item"
    print "       cpcc set         [-p projectname] inst:in.ioname value"
    print "       cpcc setf        [-p projectname] inst:in.ioname filename"
    print "       cpcc transact    [-p projectname]"
    print "       cpcc commit      [-p projectname]"
    print "       cpcc rollback    [-p projectname]"
    print "       cpcc upload      [-p projectname] upload.xml"
    print "       cpcc clear-error [-p projectname] [item]"
    print "       cpcc force-rerun [-p projectname] item"
    print ""
    print "Worker and heartbeat monitoring commands."
    print "       cpcc queue|q"
    print "       cpcc running|r "
    print "       cpcc heartbeats|h "
    print "       cpcc command-failed commandID"
    print ""
    print "Server control commands"    
    print "       cpcc init-default-server"
    print "       cpcc stop-server"
    print "       cpcc trust host port"
    print "       cpcc trust-all"  
    print "       cpcc add-node host [http_port] [https_port]"
    print "       cpcc remove-node host port"
    print "       cpcc list-nodes" 
    print "       cpcc list-sent-node-requests"
    print "       cpcc list-node-requests"
    print "       cpcc change-node-priority priority host [port]"
    print "       cpcc network-topology"
    print "       cpcc readconf"
    print ""
    print "Project Save and Load commands "
    print "       cpcc save      projectname [project-tar]"
    print "       cpcc load      project-tar projectname"
    print ""
    print "Common global options:"
    print "       cpcc [-c bundleFile]"
    sys.exit(1)

# make a copy for later
args=copy.copy(sys.argv)

if len(args)<2:
    print_usage()

# remove the 0th argument
args.pop(0)
bundleFile=None

debug=False
# first parse common options
while len(args)>0:
    if args[0][0]!='-':
        break
    elif args[0]=='-c':
        option = args.pop(0)
        if len(args) < 1:
            sys.stdout.write("ERROR: no value specified for global option '%s'\n"%
                             option)
            print_usage()
        bundleFile=args.pop(0)
    elif args[0]=='-d':
        args.pop(0)
        debug=True
    else:
        sys.stdout.write("ERROR: no command, or erroneous global option '%s'\n"%
                         args[0])
        print_usage()



def getArg(arglist, argnr, name):
    """Get argument, or print out argument description."""
    try: 
        ret=arglist[argnr]
    except IndexError:
        raise ClientError("Missing argument: %s"%name)
    return ret



def getProjectArgs(args):
    """Get argument list for project-style commands, where 
       the project name is optional. Returns a tuple
       of (projectName, options). Options is a list of 
       arguments, without the project name."""
    prevArg=None
    projectName=None
    retArgs=[]
    for arg in args:
        if prevArg == "-p":
            projectName=arg
        elif arg != "-p":
            retArgs.append(arg)          
        prevArg=arg
    if prevArg == "-p":
        raise ClientError("Missing project name")
    return (projectName, retArgs)
        
    

# now parse command and execute it.
#clnt=cpc.client(cf, args)

if len(args)>0:
    cmd=args[0]
else:
    print "ERROR: no command" 
    sys.exit(1)


# read in common configuration
cf= ConnectionBundle(bundleFile)
#cmd_line_utils.initiateConnectionBundle(bundleFile)


try:
    if cmd == "help":
        print_usage()
    elif cmd == "queue" or cmd=="q":
        clnt=ClientMessage()
        resp = clnt.listRequest("queue")
        renderMethod = CmdLine.listQueue
        ProcessedResponse(resp).pprint(renderMethod)
        #clnt=ClientMessage()
        #resp = clnt.listRequest("running")
        #renderMethod = CmdLine.listRunningQueue
        #ProcessedResponse(resp).pprint(renderMethod)
    elif cmd == "running" or cmd == "r":
        clnt=ClientMessage()
        resp = clnt.listRequest("running")
        renderMethod = CmdLine.listRunning
        ProcessedResponse(resp).pprint(renderMethod)
    elif cmd == "heartbeats" or cmd == "h":
        clnt=ClientMessage()
        resp = clnt.listRequest("heartbeats")
        renderMethod = CmdLine.listHeartbeats
        ProcessedResponse(resp).pprint(renderMethod)
    elif cmd == "command-failed":
        id=getArg(args, 1, "command ID", 0)
        #server=None
        clnt=ClientMessage()
        ProcessedResponse(clnt.commandFailedRequest(id)).pprint()
        
    # dataflow application specific messages 
    elif cmd == "start": 
        name=getArg(args, 1, "project name")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectStartRequest(name)).pprint()
    elif cmd == "remove" or cmd == "rm":
        delDir=True
        name=None
        for arg in args:
            if arg == "-k":
                delDir=False
            else:
                name=arg
        if name is None:
            raise("Missing project name for project-delete")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectDeleteRequest(name, delDir)).pprint()
    elif cmd == "projects" or cmd == "p":
        clnt=ClientMessage()
        renderMethod = CmdLine.listProjects
        ProcessedResponse(clnt.projectsRequest()).pprint(renderMethod)
    elif cmd == "set-default" or cmd == "d":
        project=getArg(args, 1, "project name")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectSetDefaultRequest(project)).pprint()
    elif cmd == "get-default":
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectGetDefaultRequest()).pprint()
    elif cmd == "list" or cmd == "ls":
        project, pargs = getProjectArgs(args)
        if len(pargs) > 1:
            item=getArg(pargs, 1, "project item to list")
        else:
            item=""
        clnt=ClientMessage()
        resp = clnt.projectListRequest(project, item)
        renderMethod = CmdLine.listActiveItems
        ProcessedResponse(resp).pprint(renderMethod)
    elif cmd == "info":
        project, pargs = getProjectArgs(args)
        item=getArg(pargs, 1, "item to get info for")
        clnt=ClientMessage()
        resp = clnt.projectInfoRequest(project, item)
        renderMethod = CmdLine.writeInfo
        ProcessedResponse(resp).pprint(renderMethod)
    elif cmd == "graph": 
        project, pargs = getProjectArgs(args)
        if len(pargs) > 1:
            item=getArg(pargs, 1, "project item to make graph of")
        else:
            item=""
        clnt=ClientMessage()
        resp = clnt.projectGraphRequest(project, item)
        renderMethod = CmdLine.makeDotGraph
        ProcessedResponse(resp).pprint(renderMethod)
    elif cmd == "log":
        project, pargs = getProjectArgs(args)
        item=getArg(pargs, 1, "instance to get log for")
        clnt=ClientMessage()
        isFile = True
        response = clnt.projectLogRequest(project, item)
        if response.content_type=="text/json":
            ProcessedResponse(response).pprint()
        else:
            filecontents = response.getRawData() #this is an mmap
            sys.stdout.write(filecontents.read(len(filecontents)))
    elif cmd == "activate":
        project, pargs = getProjectArgs(args)
        if len(pargs) > 1:
            item=getArg(pargs, 1, "project item to list")
        else:
            item=""
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectActivateRequest(project, item)).pprint()
    elif cmd == "deactivate" or cmd == "hold":
        project, pargs = getProjectArgs(args)
        if len(pargs) > 1:
            item=getArg(pargs, 1, "project item to list")
        else:
            item=""
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectHoldRequest(project, item)).pprint()
    elif cmd == "clear-error":
        project, pargs = getProjectArgs(args)
        if len(pargs) > 1:
            item=getArg(pargs, 1, "project item to list")
        else:
            item=""
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectRerunRequest(project, 
                                                   item, 
                                                   True)).pprint()
    elif cmd == "force-rerun":
        project, pargs = getProjectArgs(args)
        item=getArg(pargs, 1, "project item to list")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectRerunRequest(project, 
                                                   item, 
                                                   False)).pprint()
    elif cmd == "upload":
        project, pargs = getProjectArgs(args)
        filename=getArg(pargs, 1, "project XML file")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectUploadRequest(project, filename)).pprint()
    elif cmd == "get":
        project, pargs = getProjectArgs(args)
        item=getArg(pargs, 1, "name of input/output item to get")
        clnt=ClientMessage()
        resp = clnt.projectGetRequest(project, item)
        renderMethod = CmdLine.getItem
        ProcessedResponse(resp).pprint(renderMethod)
        #ProcessedResponse(clnt.projectGetRequest(project, item)).pprint()
    elif cmd == "get-file" or cmd == "getf":
        project, pargs = getProjectArgs(args)
        if len(pargs)<2:
            print("Missing argument: item name") 
            sys.exit(1)
        if pargs[1] == "-f":
            if len(pargs)<3:
                print("Missing argument: file name") 
            if len(pargs)<4:
                print("Missing argument: item name") 
            output=pargs[2]
            item=pargs[3]
        else:
            output=None
            item=pargs[1]
        #item=getArg(pargs, 1, "name of input/output item to get")
        #output=getArg(pargs, 2, "what we want to save the file as")
        clnt=ClientMessage()
        isFile = True
        response = clnt.projectGetRequest(project, item,isFile)
        if response.content_type=="text/json":
            ProcessedResponse(response).pprint()
        else:
            filecontents = response.getRawData() #this is an mmap
            if output is not None:
                file = open(output,"wb") 
            else:
                file = sys.stdout
            file.write(filecontents.read(len(filecontents)))
            if output is not None:
                file.close()
                print "item %s saved in %s"%(item,output)
    elif cmd == "set":
        project, pargs = getProjectArgs(args)
        item=getArg(pargs, 1, "name of input item to set")
        value=getArg(pargs, 2, "value of input item to set")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectSetRequest(project, item, value,
                                                 None)).pprint()
    elif cmd == "set-file" or cmd == "setf":
        project, pargs = getProjectArgs(args)
        item=getArg(pargs, 1, "name of input item to set")
        filename=getArg(pargs, 2, "input file to set")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectSetRequest(project, item, None,
                                                 filename)).pprint()
    elif cmd == "transact":
        project, pargs = getProjectArgs(args)
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectTransactRequest(project)).pprint()
    elif cmd == "commit":
        project, pargs = getProjectArgs(args)
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectCommitRequest(project)).pprint()
    elif cmd == "rollback":
        project, pargs = getProjectArgs(args)
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectRollbackRequest(project)).pprint()
    elif cmd == "import":
        project, pargs = getProjectArgs(args)
        module=getArg(pargs, 1, "name of module to import")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectImportRequest(project, 
                                                    module)).pprint()        
    elif cmd == "instance":
        project, pargs = getProjectArgs(args)
        fn=getArg(pargs, 1, "function name of new instance")
        name=getArg(pargs, 2, "name of new instance")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectAddInstanceRequest(project, fn, 
                                                         name)).pprint()
    elif cmd == "connect":
        project, pargs = getProjectArgs(args)
        src=getArg(pargs, 1, "connection source")
        dst=getArg(pargs, 2, "connection destination")
        clnt=ClientMessage()
        ProcessedResponse(clnt.projectConnectRequest(project, 
                                                     src, dst)).pprint()
    elif cmd == "init-default-server":
        cf.setClientHost(getArg(1, "server name"))
        print args[1] + " is now set as default server"
        #save the server address to a config file
    
    elif cmd == "trust":  
        host = getArg(args,1, "hostname")
        port = getArg(args,2,'port')
        clnt= ClientMessage()
        ProcessedResponse(clnt.grantNodeConnection(host, port)).pprint()
    
    elif cmd == "trust-all":  
        clnt= ClientMessage()
        ProcessedResponse(clnt.grantAllNodeConnections()).pprint(CmdLine.grantAllNodeConnectRequests)
    
    elif cmd == "add-node":
        host = getArg(args,1,"hostname")
        http_port = None
        https_port = None        
        if len(args)>2:
            http_port = str(getArg(args,2,'http_port'))
        
        if len(args)>3:
            https_port = str(getArg(args,3,'https_port'))
        else:
            http_port = "14807"
                  
        clnt = ClientMessage()
        ProcessedResponse(clnt.addNode(host, http_port,https_port)).pprint(CmdLine.addNodeRequest)

    elif cmd == 'list-nodes':
        clnt = ClientMessage()
        ProcessedResponse(clnt.listNodes()).pprint(CmdLine.listNodes)    
    
    elif cmd == 'list-sent-node-requests':
        clnt = ClientMessage()
        ProcessedResponse(clnt.listSentNodeConnectionRequests()).pprint(CmdLine.listSentNodeConnectRequests)    
    
    elif cmd == 'list-node-requests':
        clnt = ClientMessage()
        ProcessedResponse(clnt.listNodeConnectionRequests()).pprint(CmdLine.listNodeConnectRequests)
        
    elif cmd == "remove-node":        
        if(cf.removeNode(getArg(1, "hostname"),getArg(2,'port'))):
            print("removed node %s:%s:"%(args[1],args[2]))
            nodes = cf.getNodes()     
                        
            strs = []
            for node in nodes.nodes.itervalues():
                strs.append("%s:%s "%(node.host,node.port))
            
            print ("available nodes:"+ ','.join(strs)) 
        clnt = ClientMessage()
        ProcessedResponse(clnt.readConfRequest()).pprint()
        
    elif cmd == "change-node-priority":
        
        if len(args) >= 3:
            priority = getArg(args,1,"priority")
            host = getArg(args,2,"host")
            port = 13807
        
        if len(args)>3:
            port = getArg(3,"port")
        
        clnt = ClientMessage()
        ProcessedResponse(clnt.changeNodePriority(host,priority,port)).pprint(CmdLine.listNodes)
            
    elif cmd == "network-topology":
        clnt = ClientMessage()        
        ProcessedResponse(clnt.networkTopology()).pprint(CmdLine.networkTopology)
        
    elif cmd == "network-graph":  #calls graphviz
        
        filename = getArg(args,1,'filename')
        file = open(filename,"w")
        
        clnt = ClientMessage()        
        processedResponse = ProcessedResponse(clnt.networkTopology())
 
        file.write(CmdLine.networkTopology(processedResponse.resp[0]))
        file.close()
            
        subprocess.call(["dot","-Tsvg",filename,'-o',filename+".svg"])

    elif cmd == "readconf":
        clnt = ClientMessage()
        ProcessedResponse(clnt.readConfRequest()).pprint()
    
    elif cmd == "stop-server":
        clnt=ClientMessage()
        ProcessedResponse(clnt.stopRequest()).pprint()
    elif cmd == "save-state":
        clnt=ClientMessage()
        ProcessedResponse(clnt.saveStateRequest()).pprint()


    # save and load project commands
    elif cmd =="save":

        project= getArg(args,1,"Project name")

        savePath = "%s.tar.gz"%project
        if(len(args)>2):
            savePath=getArg(args, 2, "Destination file")

        clnt=ClientMessage()
        response = clnt.projectSaveRequest(project)

        if response.content_type=="text/json":
            ProcessedResponse(response).pprint()

        else:
            filecontents = response.getRawData() #this is an mmap
            #try catch here!! test if file can be written in destination
            try:
                file=open(savePath,"wb")
                file.write(filecontents.read(len(filecontents)))
                file.close()
            except IOError as e:
                print "Could not save project to %s\nError %s "%(savePath,
                                                                 e.strerror)
                sys.exit(1)


            print "Saved project to %s"%savePath
    elif cmd =="load":
        #provided a project file it will restore it on the server side

        #path to the file
        projectFile = getArg(args, 1, "Path to project file")  
        projectName = getArg(args, 2, "Name of project")  

        clnt=ClientMessage()
        ProcessedResponse(clnt.projectRestoreRequest(projectFile,
                                                     projectName)).pprint()
    else: 
        print "ERROR: unknown command"
except ClientError as e:
    print("ERROR: %s"%str(e))
except cpc.util.CpcError as e:
    print("ERROR: %s"%str(e))



