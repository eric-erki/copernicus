# This file is part of Copernicus
# http://www.copernicus-computing.org/
# 
# Copyright (C) 2011, Sander Pronk, Iman Pouya, Erik Lindahl, and others.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published 
# by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.



import logging
import os
import sys
import os.path
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
import traceback
import subprocess
import stat


log=logging.getLogger('cpc.dataflow.transaction')


class TransactionItem(object):
    """Common base class for transaction item types. 
      
       The actual functions are getAffected() and run(). getAffected should
       return the affected input and output active instance. These are then
       locked, and run() is called to perform the changes. 

       Between getAffected() and run(), the global project.networkLock is 
       locked.
       """
    def getAffected(self, project, affectedDestACPs, affectedOutputAIs):
        """Get the affected items of this transaction

           This is the first item to run. The affected ais are locked
           after this.

           project = the project this item belongs to
           affectedInputAIs = a set of active instances that will be 
                              updated with affected inputs generated by 
                              this change.
           affectedOutputAIs = a set of active instances that will be 
                               updated with active instances with affected 
                               inputs generated by this change.  """
        pass
    def run(self, project, sourceTag, outf=None):
        """Run the transaction item. After this run is finished, 
           handleNewInput() will be called on all affectedInputAIs.
           
           project = the project this item belongs to
           sourceTag = the source tag.
           outf = an output file to write a description of the commited change
                  to (or None)"""
        pass


class Set(TransactionItem):
    """Transaction item for setting a value."""
    def __init__(self, activeInstance, oldVal, newVal):
        """initialize based on the active instance, old value associated
           with the instance, and a new value."""
        self.activeInstance=activeInstance
        self.oldVal=oldVal
        self.newVal=newVal

    def getAffected(self, project, affectedInputAIs, affectedOutputAIs):
        """Get the affected items of this transaction"""
        ## there are no affected output AIs: only input AIs change.
        self.activeInstance.getNamedInputAffectedAIs(self.oldVal, self.newVal,
                                                     affectedInputAIs)

    def run(self, project, sourceTag, outf=None):
        """Run the transaction item."""
        self.activeInstance.stageNamedInput(self.oldVal, self.newVal, sourceTag)
        if outf is not None:
            outf.write("Set %s:%s to %s\n"%
                       (self.activeInstance.getCanonicalName(),
                        self.oldVal.getFullName(),
                        self.newVal.getDesc()))

class Connect(TransactionItem):
    """Transaction item for connecting a value"""
    def __init__(self, connection):
        self.connection=connection

    def getAffected(self, project, affectedInputAIs, affectedOutputAIs):
        """Get the affected items of this transaction"""
        # we can do this because the global lock prevents other updates
        # at the same time.
        project.active.findConnectionSrcDest(self.connection, 
                                             affectedInputAIs,
                                             affectedOutputAIs)

    def run(self, project, sourceTag, outf=None):
        """Run the transaction item."""
        project.active.addConnection(self.connection, sourceTag)
        if outf is not None:
            outf.write("Connected %s to %s\n"%(self.connection.srcString(),
                                               self.connection.dstString()))


