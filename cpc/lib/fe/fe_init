#!/usr/bin/env python

# This file is part of Copernicus
# http://www.copernicus-computing.org/
# 
# Copyright (C) 2011, Sander Pronk, Iman Pouya, Erik Lindahl, and others.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published 
# by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


import sys
import os
import os.path
#import shutil
#import glob
#import stat
#import subprocess
#import traceback
#import re
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO



import cpc.dataflow
from cpc.dataflow import StringValue
from cpc.dataflow import FloatValue
from cpc.dataflow import IntValue
from cpc.dataflow import RecordValue
from cpc.dataflow import ArrayValue


class FEError(cpc.dataflow.ApplicationError):
    pass

# we start with 2*10 lambda points
#npoints_init=10

def fe_init(inp, out):
    pers=cpc.dataflow.Persistence(os.path.join(inp.persistentDir,
                                               "persistent.dat"))

    # TODO: relaxation time
    relax_time_value=inp.getInputValue('solvation_relaxation_time')
    relax_time=relax_time_value.value
    npoints_init_value=inp.getInputValue('n_lambdas')
    npoints_init=npoints_init_value.value
    total_relax_time = relax_time*npoints_init

    if relax_time_value.isUpdated() or npoints_init_value.isUpdated():
        # create settings to be used in tuning/running
        i=0
        inSettings=inp.getInput('grompp.settings')
        valarray=[]
        if inSettings is not None:
            for value in inSettings: 
                valarray.append(value)
        valarray.append(RecordValue( { 'name' : StringValue('integrator'),
                                       'value' : StringValue('sd') } ))
        valarray.append(RecordValue( { 'name' : StringValue('free_energy'),
                                       'value' : StringValue('yes') } ))
        valarray.append(RecordValue( { 'name' : 
                                        StringValue('separate-dhdl-file'),
                                       'value' : StringValue('no')}))
        valarray.append(RecordValue( { 'name' : StringValue('delta-lambda'),
                                       'value' : StringValue('0')}))
        valarray.append(RecordValue( { 'name' : StringValue('couple_moltype'),
                                       'value' : 
                                        inp.getInputValue('coupled_mol')}))
        valarray.append(RecordValue( { 'name' : StringValue('sc-alpha'),
                                       'value' : StringValue('1.0') } ))
        valarray.append(RecordValue( { 'name' : StringValue('sc-power'),
                                       'value' : StringValue('1.0') } ))
        valarray.append(RecordValue( { 'name' : StringValue('sc-sigma'),
                                       'value' : StringValue('0.3') } ))
        valarray.append(RecordValue( { 'name' : StringValue('nsteps'),
                                        'value' : 
                                        StringValue('%d'%(relax_time) )}))
        out.setSubOut('settings', ArrayValue(valarray))

        settings_array=[]
        for i in range(npoints_init-1):
            lam_start=float(i+1)/float(npoints_init-1)
            # specific settings for relaxation
            # coulomb
            mdp=[]
            mdp.append(RecordValue( { 'name' : StringValue('couple-lambda0'),
                                       'value' : StringValue('vdwq')}))
            mdp.append(RecordValue( { 'name' : StringValue('couple-lambda1'),
                                       'value' : StringValue('vdw') }))
            #mdp.append(RecordValue( { 'name' : StringValue('delta-lambda'),
            #                          'value' : 
            #                          StringValue('%g'%(1/total_relax_time))}))
            mdp.append(RecordValue( { 'name' : StringValue('init-lambda'),
                                       'value' : StringValue('%g'%lam_start)}))
            settings_array.append(ArrayValue(mdp))
        for i in range(npoints_init-1):
            lam_start=float(i+1)/float(npoints_init-1)
            # specific settings for relaxation
            # coulomb
            mdp=[]
            # vdw
            mdp.append(RecordValue( { 'name' : StringValue('couple-lambda0'),
                                       'value' : StringValue('vdw') }))
            mdp.append(RecordValue( { 'name' : StringValue('couple-lambda1'),
                                       'value' : StringValue('none') }))
            #mdp.append(RecordValue( { 'name' : StringValue('delta-lambda'),
            #                          'value' : 
            #                          StringValue('%g'%(1/total_relax_time))}))
            mdp.append(RecordValue( { 'name' : StringValue('init-lambda'),
                                       'value' : StringValue('%g'%lam_start)}))
            settings_array.append(ArrayValue(mdp))
        out.setSubOut('settings_array', ArrayValue(settings_array))

    # here we create an entirely new sampling set.
    notune=True
    tune=pers.get('tune')
    #sys.stderr.write("%s, %s"%(len(inp.getInput('resources.min')), 
    #                           len(inp.getInput('resources.max'))))
    if tune is None and ((inp.getInput('resources.min') is None or 
                          len(inp.getInput('resources.min')) ==0 ) and
                         (inp.getInput('resources.max') is None or 
                          len(inp.getInput('resources.max')) ==0 )) :
        tune=1
        # create a tuning instance
        out.addInstance('mdrun_tune', 'gromacs::mdrun_tune')
        # connect everything to it
        out.addConnection('self:ext_in.grompp.mdp', 'mdrun_tune:in.mdp')
        out.addConnection('self:ext_in.grompp.top', 'mdrun_tune:in.top')
        out.addConnection('self:ext_in.grompp.include', 
                          'mdrun_tune:in.include')
        out.addConnection('self:sub_out.settings', 'mdrun_tune:in.settings')
        out.addConnection('self:ext_in.grompp.ndx', 'mdrun_tune:in.ndx')
        out.addConnection('self:ext_in.conf', 'mdrun_tune:in.conf')
        # connect its output to the subnet inputs of self
        out.addConnection('mdrun_tune:out.resources', 'self:ext_out.resources')
        out.addConnection('mdrun_tune:out.mdp', 'self:ext_out.mdp')
        pers.set("tune", tune)
        notune=False

    merge_mdp=pers.get('merge_mdp')
    if notune and merge_mdp is None:
        # if we don't need tuning, we still need to merge mdps
        merge_mdp=1
        out.addInstance('merge_mdp', 'gromacs::merge_mdp')
        out.addConnection('self:ext_in.grompp.mdp', 'merge_mdp:in.mdp')
        out.addConnection('self:sub_out.settings', 'merge_mdp:in.settings')
        out.addConnection('merge_mdp:out.mdp', 'self:ext_out.mdp')
        pers.set("merge_mdp", merge_mdp)

    # now create the runs.
    mdrun=pers.get('mdrun')
    if mdrun is None or mdrun != npoints_init:
        if mdrun is None:
            mdrun=0
        else:
            raise FEError("Change in n_lambdas not yet implemented")
        # these are the multiple runs
        out.addInstance('grompps', 'gromacs::grompp_multi')
        out.addInstance('mdruns', 'gromacs::mdrun_multi')
        # connect the tpr, mdp and resources
        out.addConnection('grompps:out.tpr', 'mdruns:in.tpr')
        out.addConnection('self:ext_in.grompp.top', 'grompps:in.top[0]')
        out.addConnection('self:ext_in.grompp.ndx', 'grompps:in.ndx[0]')
        out.addConnection('self:ext_in.grompp.include', 'grompps:in.include[0]')
        out.addConnection('self:ext_in.grompp.mdrun_cmdline_options', 
                          'mdruns:in.cmdline_options[0]')
        if not notune:
            out.addConnection('mdrun_tune:out.resources', 
                              'mdruns:in.resources[0]')
            out.addConnection('mdrun_tune:out.mdp', 'grompps:in.mdp[0]')
        else:
            out.addConnection('self:ext_in.resources', 
                              'mdruns:in.resources[0]')
            out.addConnection('merge_mdp:out.mdp', 'grompps:in.mdp[0]')
        out.addConnection('self:sub_out.settings_array', 
                          'grompps:in.settings')
        # set the individual configurations and connect the outputs
        # coulomb first
        for i in range(0, npoints_init-1):
            # connect the confs
            if i == 0:
                out.addConnection('self:ext_in.conf', 'grompps:in.conf[0]')
            else:
                out.addConnection('mdruns:out.conf[%d]'%(i-1), 
                                  'grompps:in.conf[%d]'%i)
            # and the outputs
            if i == 0:
                # add the fixed one
                out.addConnection('self:ext_in.conf', 
                                  'self:ext_out.paths[0].lambdas[0].conf')
            out.addConnection('mdruns:out.conf[%d]'%i, 
                              'self:ext_out.paths[0].lambdas[%d].conf'%(i+1))
            # the last of the coulombs is the first of the vdw
            if i == npoints_init-2:
                out.addConnection('mdruns:out.conf[%d]'%i, 
                                  'self:ext_out.paths[1].lambdas[0].conf')
        for j in range(0, npoints_init-1):
            #npoints_init-1, 2*(npoints_init-1)):
            i=j+npoints_init-1
            out.addConnection('mdruns:out.conf[%d]'%(i-1), 
                              'grompps:in.conf[%d]'%i)
            #if j == 0:
            #    out.addConnection('mdruns:out.conf[%d]'%(i-1), 
            #                      'self:ext_out.paths[1].lambdas[%d].conf'%
            #                      (j+1))
            out.addConnection('mdruns:out.conf[%d]'%i, 
                              'self:ext_out.paths[1].lambdas[%d].conf'%(j+1))

        # Set the lambda values.
        # set lambda array outputs for coulomb + vdw
        out.setOut('paths[0].a', StringValue('vdwq'))
        out.setOut('paths[0].b', StringValue('vdw'))
        out.setOut('paths[1].a', StringValue('vdw'))
        out.setOut('paths[1].b', StringValue('none'))
        for i in range(npoints_init):
            lam=float(i)/float(npoints_init-1)
            out.setOut('paths[0].lambdas[%d].lambda'%i, FloatValue(lam))
        for i in range(npoints_init):
            lam=float(i)/float(npoints_init-1)
            out.setOut('paths[1].lambdas[%d].lambda'%i, FloatValue(lam))
            #out.setOut('confs[%d].lambda.coulomb'%j, FloatValue(1))
            #out.setOut('confs[%d].lambda.vdw'%j, FloatValue(lam))
        mdrun=npoints_init
        pers.set("mdrun", mdrun)

    pers.write()
    return out



# read the input data
inf=StringIO()
inf.write(sys.stdin.read())
inf.seek(0)
sys.stderr.write("\n-----> Starting\n")
inf.seek(0)
inp=cpc.dataflow.readInput(inf)

if inp.testing():
    # TODO: make it possible for sub-functions to be checked now.
    cpc.util.plugin.testCommand("g_bar -version")
    cpc.util.plugin.testCommand("grompp -version")
    cpc.util.plugin.testCommand("trjconv -version")
    cpc.util.plugin.testCommand("gmxdump -version")
    # try to import msmproject and thereby msmbuilder
    sys.exit(0)



# prepare the output data
out=inp.getFunctionOutput()

fe_init(inp, out)

out.writeXML(sys.stdout)
#sys.stderr.write('\n')
#out.writeXML(sys.stderr)
#sys.stderr.write('\n')
sys.stderr.write("-----> Finished.\n")


