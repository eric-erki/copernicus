#!/usr/bin/env python

# This file is part of Copernicus
# http://www.copernicus-computing.org/
# 
# Copyright (C) 2011-2014, Sander Pronk, Iman Pouya, Erik Lindahl, and others.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published 
# by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


import sys
import os
import math
import time
import dihedral_restraints
import os.path
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import cpc.dataflow
from cpc.dataflow import StringValue
from cpc.dataflow import FloatValue
from cpc.dataflow import IntValue
from cpc.dataflow import RecordValue
from cpc.dataflow import ArrayValue
from cpc.dataflow import FileValue

from subprocess import Popen

class FEError(cpc.dataflow.ApplicationError):
    pass


def swarm(inp, out):
    pers=cpc.dataflow.Persistence(os.path.join(inp.getPersistentDir(), "persistent.dat"))
    
    # TODO allow additional iterations to be set by having each iteration within pers object
    
    iterations=pers.get('iterations')
    if iterations is None or iterations<1:
        Niterations=inp.getInput('Niterations')
        # Niterations is an optional input, path converge may also be 
        #used to monitor iterations
        # BW: Note, removed opt flag on Niterations as this is not implemented here anyway now.
    #if Niterations is not None:

        start=inp.getInput('start_conf')
        start_xvg=inp.getInput('start_xvg')
        end=inp.getInput('end_conf')
        end_xvg=inp.getInput('end_xvg')
        n=inp.getInput('Ninterpolants')
        ndx=inp.getInput('res_index')         # what residues to use for the dihedral interpolation
        tpr=inp.getInput('tpr')
        Nchains=inp.getInput('Nchains')

        out.addInstance('mdrun_tune','gromacs::mdrun_tune')
        out.addConnection('self:ext_in.start_conf', 'mdrun_tune:in.conf')
        # The tuning run uses the equilibration settings
        out.addConnection('self:ext_in.equi_grompp.mdp', 'mdrun_tune:in.mdp')
        out.addConnection('self:ext_in.top', 'mdrun_tune:in.top')
        out.addConnection('self:ext_in.include', 'mdrun_tune:in.include')
        
        includes=[]
        inc_array=inp.getInput('include')
        if inc_array is not None:
            for i in range(len(inc_array)):
                includes.append(inp.getInput('include[%d]'%i))
        # if the include array is none, the single chain is in topol.top
        top=inp.getInput('top')
        
        # Interpolate the dihedral coordinates between the given start and end
        # structures and write out as dihedral restraint include files dihre_N_chain_Y.itp
        #
        # ndx is the residue list to use for dihedrals

        dihedral_restraints.write_restraints(start, end, start_xvg, end_xvg, 
                                             top, includes, n, ndx, Nchains)
        
        # Setup the subnet's path output with a config, top and itp.
        # 
        # Use these dihedral restraint includes to set as include inputs for the
        # configs of the initial path. These are set through a subnet, which is connected
        # to the first iteration iter0 further below (sub_out.path -> iter0:in.path)
        #
        # Since we don't move the start and end points, we are really going to process
        # only the path points 1 to n-2 (if n is the total number of points and we start at 0).
        # Let i reflect the "true" point index, but the arrays have to start at 0, hence the i-1
        # everywhere below.

        for i in range(1,n-1):  # range(a,b) gives numbers from a to b-1.
            
            # Same starting configuration for each point
            out.setSubOut('path[%d].conf'%(i-1), FileValue(start))

            # One topology file per path point. These are also written by dihedral_restraints
            # but are simply passed through from the top level topology input, with the
            # specific .itp added as an include directive

            #if len(includes)==0:
            top_i=os.path.join(inp.getOutputDir(),'topol_%d.top'%i)
            out.setSubOut('path[%d].top'%(i-1), FileValue(top_i))
            #else:
            #    out.setSubOut('path[%d].top'%(i-1), FileValue(top))
            # connect includes output by write_restraints

            # One restraint itp per chain in the protein

            for chain in range(Nchains):
                include_i=os.path.join(inp.getOutputDir(),'dihre_%d_chain_%d.itp'%(i,chain))
                out.setSubOut('path[%d].include[%d]'%(i-1,chain), FileValue(include_i))

            # Connect any other includes as itp's after the chain restraint itps

            if len(includes)>Nchains:
                for j in range(Nchains,len(includes)):
                    include=inp.getInput('include[%d]'%j)
                    out.setSubOut('path[%d].include[%d]'%(i-1,j),
                                              FileValue(include))
        
        # Create the dihedral swarm iteration instances
        for i in range(Niterations):
            # The dihedral_swarm_iteration is completely described by the corresponding
            # section in the _import.xml file, as a network function with sub-instances.
            out.addInstance('iter%d'%i, 'dihedral_swarm_iteration')

            # Initial input points - these are used by the reparametrize step to "stretch"
            # the path well between the start and end points (which are fixed), as the 
            # individual path points in between move around
            out.addConnection('self:ext_in.start_conf', 'iter%d:in.start_conf'%i)
            out.addConnection('self:ext_in.start_xvg', 'iter%d:in.start_xvg'%i)
            out.addConnection('self:ext_in.end_conf', 'iter%d:in.end_conf'%i)
            out.addConnection('self:ext_in.end_xvg', 'iter%d:in.end_xvg'%i)

            out.addConnection('self:ext_in.Ninterpolants', 'iter%d:in.Ninterpolants'%i)

            # Dihedral selection index
            out.addConnection('self:ext_in.res_index', 'iter%d:in.resindex'%i)
            out.addConnection('self:ext_in.tpr', 'iter%d:in.tpr'%i)

            # Topology 
            out.addConnection('self:ext_in.top', 'iter%d:in.top'%i)

            # Topology include files
            out.addConnection('self:ext_in.include', 'iter%d:in.include'%i)
            
            # Propagate the various run settings into the functions in the iteration

            # Minimization
            out.addConnection('self:ext_in.minim_grompp', 'iter%d:in.minim_grompp'%i)
            out.addConnection('self:ext_in.em_tolerance', 'iter%d:in.em_tolerance'%i)
            out.addConnection('self:ext_in.minim_doubleprec', 'iter%d:in.minim_doubleprec'%i)

            # Thermalization
            out.addConnection('self:ext_in.therm_grompp', 'iter%d:in.therm_grompp'%i)

            # Equilibration (and used for the swarm production runs as well)
            out.addConnection('self:ext_in.equi_grompp', 'iter%d:in.equi_grompp'%i)
            out.addConnection('self:ext_in.restrained_steps', 'iter%d:in.restrained_steps'%i)

            # Note: Minimization, thermalization and equilibration uses quite hard dihedral restraints, 
            # especially the minimization step has to do this to force the structure into the new iterations
            # configuration. The swarm production run has no dihedral restraints.

            # Setup some other configuration parameters
            out.addConnection('self:ext_in.swarm_steps', 'iter%d:in.swarm_steps'%i)
            out.addConnection('self:ext_in.Nswarms', 'iter%d:in.Nswarms'%i)
            out.addConnection('self:ext_in.Nchains', 'iter%d:in.Nchains'%i)
            out.addConnection('mdrun_tune:out.resources', 'iter%d:in.resources'%i)

            # The refined path from each iteration is output as an array of paths
            out.addConnection('iter%d:out.path'%i, 'self:ext_out.paths[%d]'%i)

            # The refined path from each iteration connects to the next iterations
            # input, and the first iteration gets the dihedrally interpolated path as
            # starting path
            if i>0:
                out.addConnection('iter%d:out.path'%(i-1), 'iter%d:in.path'%i)
            else:  
                out.addConnection('self:sub_out.path', 'iter0:in.path')

        iterations=1

    # use pers.get to pass the function args to the various subfunctions
    pers.set('iterations', iterations)
    pers.write()

# read the input data
inf=StringIO()
inf.write(sys.stdin.read())
inf.seek(0)
sys.stderr.write("\n-----> Starting\n")
inf.seek(0)
inp=cpc.dataflow.readInput(inf)

if inp.testing():
    # TODO: make it possible for sub-functions to be checked now.
    cpc.util.plugin.testCommand("g_bar -version")
    cpc.util.plugin.testCommand("grompp -version")
    cpc.util.plugin.testCommand("trjconv -version")
    cpc.util.plugin.testCommand("gmxdump -version")
    # try to import msmproject and thereby msmbuilder
    sys.exit(0)

# prepare the output data
out=inp.getFunctionOutput()

swarm(inp, out)

out.writeXML(sys.stdout)
#sys.stderr.write('\n')
#out.writeXML(sys.stderr)
#sys.stderr.write('\n')
sys.stderr.write("-----> Finished.\n")


