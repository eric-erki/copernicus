#!/usr/bin/env python

# This file is part of Copernicus
# http://www.copernicus-computing.org/
# 
# Copyright (C) 2011-2014, Sander Pronk, Iman Pouya, Erik Lindahl and others.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as published 
# by the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


import sys
import os
import math
import os.path
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

import cpc.dataflow
from cpc.dataflow import StringValue
from cpc.dataflow import FloatValue
from cpc.dataflow import IntValue
from cpc.dataflow import RecordValue
from cpc.dataflow import ArrayValue
from cpc.dataflow import FileValue

class FEError(cpc.dataflow.ApplicationError):
    pass

# Thermalize the system and relax it with the new constraints
# short integration timestep is employed to properly evolve the
# initially unstable system

# TODO: sets dihrefc 100 below, but the .itp file has the k-fac now under gromacs 4.5+

def run(inp, out):
    pers=cpc.dataflow.Persistence(os.path.join(inp.getPersistentDir(),"persistent.dat"))

    merge=pers.get('merge')
    if merge is None or merge==0:
        merge=1
        out.addInstance('merge', 'gromacs::merge_mdp')
        out.addConnection('self:ext_in.grompp.mdp', 'merge:in.mdp')
        out.addConnection('self:ext_in.grompp.settings', 'merge:in.settings')
        # thermalize for 5000 steps
        settings=[] 
        # Note: in older Gromacs, the dihre options were controlled from here too.
        # TODO: the dihedral restraints here could maybe be allowed to be more relaxed
        # than in the minimization and equilibration (?). But since the dihre_kfac option is
        # no more, we have to then generate a separate dihedral restraints .itp file for this step.
        settings.append(RecordValue( { 'name' : StringValue('integrator'),
                                       'value' : StringValue('sd') } ) )
        settings.append(RecordValue( { 'name' : StringValue('dt'),
                                       'value' : StringValue('0.0005') } ) )
        settings.append(RecordValue( { 'name' : StringValue('nsteps'),
                                       'value' : StringValue('1000') } ) )   # 5000, just testing
        settings.append(RecordValue( { 'name' : StringValue('nstfout'),
                                       'value' : StringValue('0') } ) )
        settings.append(RecordValue( { 'name' : StringValue('nstxtcout'),
                                       'value' : StringValue('0') } ) )
        settings.append(RecordValue( { 'name' : StringValue('nstlog'),
                                       'value' : StringValue('10000') } ) )
        # BW: nstenergy has to be a multiple of nstcalcenergy now, which is not set here (autotuned)
        # Check if this poses a problem for the analysis later on.
        #settings.append(RecordValue( { 'name' : StringValue('nstenergy'),
        #                               'value' : StringValue('120') } ) )
        out.setSubOut('restrained_settings', ArrayValue(settings))
    pers.set('merge', merge)

    mdruns=pers.get('mdruns')
    if mdruns is None or mdruns==0:
        # Create a network instance that runs multiple grompp/mdruns in parallell
        out.addInstance('runs', 'gromacs::grompp_mdruns')

        # Inputs to mdruns are in arrays, and if we fill one entry that goes to all simulations, but if we
        # fill all entries each have their own

        # The index file, cmdline options and resources  are the same for all
        out.addConnection('self:ext_in.grompp.ndx', 'runs:in.ndx[0]')
        out.addConnection('self:ext_in.grompp.mdrun_cmdline_options',
                          'runs:in.cmdline_options[0]')
        out.addConnection('self:ext_in.resources', 'runs:in.resources[0]')

        # The project settings are the same for all as well, but come from the merge function output
        # instead of directly from an input file
        out.addConnection('merge:out.mdp', 'runs:in.mdp[0]')

        out.addConnection('self:sub_out.restrained_settings', 
                          'runs:in.settings[0]')

        #out.addConnection('runs:out.trr', 'self:sub_in.trrs')

        # We get an array of configurations (.gro's), topologies and topology-include files - one set for
        # each point in the swarm - in self:ext_in.path[*].conf/top/include, and we are supposed to produce
        # a corresponding array on the output.
        #
        # The output is self:ext_out.path[*] which is a conf_path of path_points (conf/top/include)
        # In the code below the conf is not used (!)
        # The output *also* has a self:ext_out.confs[*] array of filenames to configs.

        # Create a connection that connects each entry in the input array to each grompp_mdruns multi-
        # input, the mdruns configuration output to the output array, and bypass the topologies for each
        # input directly to the output.

        in_confs=inp.getInput('path')
        for i in range(len(in_confs)):
            # Split the input path element and connect input configuration, topology and topology-include to 
            # grompp/mdruns (separate for each swarm point)
            out.addConnection('self:ext_in.path[%d].conf'%i,'runs:in.conf[%d]'%i)
            out.addConnection('self:ext_in.path[%d].top'%i,'runs:in.top[%d]'%i)
            out.addConnection('self:ext_in.path[%d].include'%i,'runs:in.include[%d]'%i)
            # The output configuration goes to the proper entry in the output array
            out.addConnection('runs:out.conf[%d]'%i, 'self:ext_out.path[%d].conf'%i)
            # TODO: we can probably remove the confs array as that is redundant (why was it there?)
            out.addConnection('runs:out.conf[%d]'%i, 'self:ext_out.confs[%d]'%i)
            # The topologies are bypassed from the input to the output
            # It is important that these are immediately propagated here on the first run of the function,
            # since the path[] array elements have to be created, otherwise the "complete" flag which is set for
            # path in the _import.xml definition will not halt the pipeline until we have all the path[].conf's.
            out.addConnection('self:ext_in.path[%d].top'%i,'self:ext_out.path[%d].top'%i)
            out.addConnection('self:ext_in.path[%d].include'%i,'self:ext_out.path[%d].include'%i)

        # mark that we created the mdruns fn and connections
        mdruns=1
    pers.set('mdruns', mdruns)

    pers.write()

# read the input data
inf=StringIO()
inf.write(sys.stdin.read())
inf.seek(0)
sys.stderr.write("\n-----> Thermalization Starting\n")
inf.seek(0)
inp=cpc.dataflow.readInput(inf)

if inp.testing():
    # TODO: make it possible for sub-functions to be checked now.
    cpc.util.plugin.testCommand("g_bar -version")
    cpc.util.plugin.testCommand("grompp -version")
    cpc.util.plugin.testCommand("trjconv -version")
    cpc.util.plugin.testCommand("gmxdump -version")
    # try to import msmproject and thereby msmbuilder
    sys.exit(0)


# prepare the output data
out=inp.getFunctionOutput()

run(inp, out)

out.writeXML(sys.stdout)
#sys.stderr.write('\n')
#out.writeXML(sys.stderr)
#sys.stderr.write('\n')
sys.stderr.write("-----> Finished.\n")


