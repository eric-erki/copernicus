import sys
import os.path
from socket import gethostname
import stat
import json
from cpc.util import CpcError
import re
import cpc.util.ca_conf_template
from cpc.network.node import Node
from cpc.util import json_serializer
import exception

# the default port number, based on the
# first 5 decimals of Boltzmann's constant:
portnr=13807
defaultPort=13807
# default host to listen() to, "" means everybody
server_host=""
# the default hostname the client connects to
client_host="localhost"


class ConfError(exception.CpcError):
    pass


class InputError(CpcError):
    def __init__(self,exc):
        self.str=exc.__str__()
        
        
class ConfValue:
    """Configuration value. Each configuration value has a name, and a
       default value. If the value is user settable, there can be a 
       set value."""
    def __init__(self, name, defaultValue, description, userSettable=False, 
                 setValue=None, relTo=None,validation=None,allowedValues=None):
        self.name=name
        self.defaultValue=defaultValue
        self.description=description
        self.userSettable=userSettable
        self.setValue=setValue
        self.relTo=relTo
        self.validation = validation  #a regexp that validates the correct input
        self.allowedValues = allowedValues # list of allowed values for this config parameter

    def get(self):
        """Get the current value."""
        if self.setValue is not None:
            return self.setValue
        else:
            return self.defaultValue
    def set(self, newValue):
        """Set a new value."""        
        if self.validation !=None:                        
            regexp = re.compile(self.validation)
            
            match = regexp.match(newValue)
            if match == None:
                raise InputError("The value %s must match %s"%(newValue,self.validation))
            
        if self.allowedValues !=None:            
            try:
                self.allowedValues.index(newValue)
            except ValueError: 
                allowedValuesStr = ','.join(self.allowedValues)                                
                raise InputError("The value %s does not match any of %s"%(newValue,allowedValuesStr))  #Throw an exception with a message
        
                      
        self.setValue=newValue

    def reset(self):
        """Reset the value to the default value."""
        self.setValue=None

    def hasSetValue(self):
        """Check whether the configuration setting has been set to something
            else than the default value."""            
        return (self.setValue is not None)

    def isUserSettable(self):
        """Check whether the 'user settable' flag has been set for this 
           value."""
        return self.userSettable

class Conf:
    """Common configuration class. Reads from copernicus base directory"""
    __shared_state = {}   

    def __init__(self,conffile=None, confdir = None,reInit =False):
        """Read basic configuration stuff"""
        # all objects created will share the same state
        self.__dict__ = self.__shared_state   
        # check whether we initialized it already and bail out if we did
        if len(self.__shared_state) > 0 and reInit == False:
            # if we have asked for another conf file
            if conffile!=None and conffile!= self.__shared_state['conf_file']:  
                return

        # initialize for the first time:
        self.conf = dict()
        self.hostname=gethostname()
        #self.conf['hostname'] = gethostname()
        
        # We first need to find out where our configuration files are.
        self._add('global_dir', os.path.join(os.environ["HOME"],
                                             ".copernicus"),
                  'The global configuration directory',
                  userSettable=True)
        self._add('conf_dir', os.path.join(os.environ["HOME"],
                                           ".copernicus",
                                           self.hostname),
                  'The configuration directory',
                  userSettable=True)
        if confdir is not None:
            self.conf['conf_dir'].set(confdir)
        # once we have the directory, we use the default filename:
        
        
        self._add('conf_file',conffile, 'The configuration file name',
                  relTo='conf_dir')



        #FIXME generalize layered solution 
        # find the base directory of the executable for plugins
        dn=os.path.dirname(sys.argv[0])
        self.execBasedir = ''
        if dn != "":
            self.execBasedir=os.path.abspath(dn)
            self._add('exec_base_dir', self.execBasedir, 
                      'executable base directory')

        # then set the default values for the conf. values
        self.initDefaults()        
        # and read in the actual values from the configuration file.
        self.have_conf_file = self.tryRead() 
              

    def _add(self, name, defaultValue, desc, userSettable=False, relTo=None,validation=None,allowedValues =None):
        """Add a configuration value with a default value, description"""
        self.conf[name] = ConfValue(name, defaultValue, desc, 
                                    userSettable=userSettable,
                                    relTo=relTo,validation=validation,allowedValues=allowedValues)
       
    def tryRead(self):
        try:   
            confname = self.getFile('conf_file')
            #self.conf = pickle.loads(f.read())
            f = open(confname,'r')  
            str = f.read()
            try:
                #print str
                nconf = json.loads(str,object_hook = json_serializer.fromJson)
                # merge items
                for (key, val) in nconf.iteritems():
                    if self.conf.has_key(key):
                        self.conf[key].set(val)
                    # if it doesn't exist as a key, we ignore it.
            except Exception as e:
                print("ERROR: %s"%e)
                    
            return True
        except:
            # there was no configuration file. 
            # at least try to make the directory
            # also initiating an empty file
            try:
                dirname=os.path.dirname(confname)
                os.makedirs(dirname)
                os.chmod(dirname, stat.S_IRWXU)
                confFile = open(confname,"w")
                conf=dict()
                confFile.write(json.dumps(conf))        
                confFile.close()
            except:
                pass
            return False

    def write(self):
        # write all conf settings that have non-default values to file.
        confname = self.getFile('conf_file')
        try:
            dirname=os.path.dirname(confname)
            os.makedirs(dirname)
            os.chmod(dirname, stat.S_IRWXU)
        except EnvironmentError as (errno,strerror):            
            print "could not create dir  %s received oserror: %s , %s"%(dirname,errno,strerror)
           
        f = open(confname,"w")
        # construct a dict with only the values that have changed from 
        # the default values
        conf=dict()
        

        for cf in self.conf.itervalues():
            if cf.hasSetValue():
                conf[cf.name] = cf.get()
        # and write out that dict.
        
        f.write(json.dumps(conf,default = json_serializer.toJson,indent=4))
                
        f.close()

    def reread(self):
        """Update from configuration file. First reset all values, then 
           read them from disk."""
        for val in self.conf.itervalues():
            val.reset()
        self.tryRead()

    def get(self, name):
        """Get the current value associated with this configuration."""
        return self.conf[name].get()

    def getFile(self, name):
        """Get a full path name based on a configuration name.
           Expands 'relTo' names iteratively."""
        nameval=self.conf[name].get()
        if os.path.isabs(nameval):
            # in this case we're done quickly
            return nameval
        retpath=nameval
        curRel=self.conf[name].relTo
        while curRel is not None:
            # now iteratively traverse the reverse path
            retpath=os.path.join(self.conf[curRel].get(), retpath)
            curRel=self.conf[curRel].relTo
        return retpath

    def set(self, name, value):
        """Set a new value associated with this configuration."""
        try:
            self.conf[name].set(value)
            self.write()            
        except KeyError:
            raise InputError("The config parameter %s do not exist"%(name))    

    def userSet(self, name, value):
        """Set a new value associated with this configuration while checking
           whether that value can be set by a user."""
        if self.conf[name].isUserSettable():
            self.conf[name].set(value)
        else:
            raise ConfError("Value of '%s' is not user settable"%name)

    def isUserSettable(self, name):
        return self.conf[name].isUserSettable()

    def confFileValid(self):
        return self.have_conf_file

    def initDefaults(self):
        # the default hostname that the client connects to
        self._add('client_host', client_host, 
                  "Hostname for the client to connect to", True)
        self._add('client_port', portnr, 
                  "Port number for the client to connect to", True,None,'\d+')

        self._add('server_host', server_host, 
                  "Address the server listens on", True)
        self._add('server_port', portnr,
                  "Port number the server listens on", True,None,'\d+')

        self._add('parent_nodes', dict(), 
                  "List of parent nodes for the server", True)
        self._add('child_nodes',dict(),
                  "List of child nodes for the server", True)


        self._add('project_file', "projects.xml", 
                  "Projects file name (relative to conf_dir)",
                  relTo='conf_dir')

        self._add('run_dir', os.path.join(os.environ["HOME"],
                                          "copernicus",
                                          "run"),
                  "The run directory for the run client",
                  True)
        self._add('local_executables_dir', "executables",
                  "Directory containing executables for the run client. Part of executables_path",
                  False,
                  relTo='conf_dir')
        self._add('global_executables_dir', "executables",
                  "The directory containing executables for the run client. Part of executables_path",
                  False,
                  relTo='global_dir')
        self._add('executables_path', "",
                  "Colon-separated list of directories to search for executables",
                  True)


        self._add('plugin_path', "", 
                  "Colon-separated list of directories to search for plugins",
                  True)

        self._add('module_dir', self.execBasedir, 
                  "Directory containing copernicus modules",
                  True)

        self._add('mode','prod',
                  "The run mode of the server",
                  True,None,None,['debug','prod'])

        # log options
        self._add('log_dir', "log",
                  "Directory containing logs",
                  True,
                  relTo='conf_dir')
        self._add('server_log_file', "server.log",
                  "The server log file", False, 
                  relTo='log_dir')
        self._add('error_log_file', "error.log",
                  "The error log file", False, 
                  relTo='log_dir')


        # heartbeat options
        self._add('heartbeat_time', 120,
                  "Time in seconds between heartbeats",
                  True, validation='\d+')
        self._add('heartbeat_file', "heartbeatlist.xml",
                  "Heartbeat monitor list", False,
                  relTo='conf_dir')


                #static configuration
        self._add('web_root', 'web',
                  "The directory where html,js and css files are located")

        #OPENSSL CA configurtions; static configurations that should not change 
        self._add('ca_dir', "ca", 
                  "Base SSL CA directory (relative to conf_dir)",
                  relTo='conf_dir')
        self._add('server_key_dir', "keys", 
                  "Server key directory (relative to ca_dir)",
                  relTo="ca_dir")
        self._add('server_cert_dir', "certs", 
                  "Server certificate directory (relative to ca_dir)",
                  relTo="ca_dir")
        self._add('priv_key_file', "priv.pem", 
                  "Server private key file (relative to server_cert_dir)",
                  relTo="server_cert_dir")
        self._add('pub_key_file', "pub.pem", 
                  "Server public key file (relative to server_cert_dir)",
                  relTo="server_cert_dir")
        self._add('cert_file', "ca_cert.pem", 
                  "Server certificate file (relative to ca_dir)",
                  relTo="ca_dir")
        self._add('cert_request_file', "root_ca_request.pem", 
                  "Server certificate signing request file (relative to server_cert_dir)",
                  relTo="server_cert_dir")
        self._add('cachain_file', "cachain.pem", 
                  "Server CA chain file (relative to ca_dir)",
                  relTo="ca_dir")
        self._add('caconf_file', "caconf", 
                  "CA configuration file (relative to ca_dir)",
                  relTo="ca_dir")
        self._add('server_serial_file', "serial", 
                  "Server serial file (relative to ca_dir)",
                  relTo="ca_dir")
        self._add('server_index_file', "index.txt",
                  "Server index file (relative to ca_dir)",
                  relTo="ca_dir")

    def getPluginPaths(self):
        lst=self.conf['plugin_path'].get().split(':')
        retlist=[]
        for ls in lst:
            str=ls.strip()
            if str != "":
                retlist.append(str)
        retlist.append(os.path.join(self.execBasedir, 'cpc', 'plugins'))
        return retlist
    def getModuleBasePath(self):
        return self.conf['module_dir'].get()

    #    def getRundir(self):
    #        return self.readCounf('rundir')

    #write functions
       
    def setServerHost(self,serverAddress):        
        return self.set('server_host',serverAddress)                
    def setClientHost(self,address):        
        return self.set('client_host',address)
                    
    def addParentNode(self,host,port=None):        
        return self.addNode(host, port,True)
     
    def addChildNode(self,host,port=None):        
        return self.addNode(host, port,False)
        
    #private method, adding child and parent nodes share the same functionality
    def addNode(self,host,port=None,parentNode = True):        
        """adds a server to the list of servers that this server can connect 
           to."""    
        if port == None:
            port = defaultPort 
        
        if parentNode:           
            nodes=self.conf['parent_nodes'].get()
        else:
            nodes = self.conf['child_nodes'].get()    
        
        key = "%s:%s"%(host,port)  
        node = Node(host,port)
                       
        nodes[key] = node
        
        if parentNode:
            self.conf['parent_nodes'].set(nodes)
        else:
            self.conf['child_nodes'].set(nodes)
        self.write()
             
        return True 


    def removeParentNode(self,host,port=None):
        return self.removeNode(host, port, True)
 
    def removeChildNode(self,host,port=None):
        return self.removeNode(host, port, False)
    
    def removeNode(self,host,port=None,parentNode=True):
        if port == None:
            port = defaultPort 
        
        if parentNode:           
            nodes=self.conf['parent_nodes'].get()
        else:
            nodes = self.conf['child_nodes'].get()   
        
        key = "%s:%s"%(host,port)
        if key in nodes:
            del nodes[key]
        
        if parentNode:
            self.conf['parent_nodes'].set(nodes)
        else:
            self.conf['child_nodes'].set(nodes)
        
        self.write()
        
        return True

    def getLogDir(self):
        return self.getFile('log_dir')
 
    def getServerLogFile(self):
        return self.getFile('server_log_file')
 
    def getErrorLogFile(self):
        return self.getFile('error_log_file')


    def getHeartbeatTime(self):
        return int(self.conf['heartbeat_time'].get())
    def getHeartbeatFile(self):
        return self.getFile('heartbeat_file')
 
    def setMode(self,mode):
        self.conf['mode'].set(mode)
    
    def hasParent(self):
        return (len(self.conf['parent_nodes'].get()) > 0)
    
    def isDebug(self):
        if self.conf['mode'].get() == 'debug':
            return True
        else:
            return False
                   
    # get functions
    
    def getUserSettableConfigs(self):
        configs = dict()
        for key,value in self.conf.iteritems():
            if value.userSettable == True:
                configs[key] = value
        
        return configs
        
    
    def getParent(self):
        #NOTE this should be extended so that it choses the parent 
        # with the highest prioirity
        parentNodes = self.conf['parent_nodes'].get()
        return parentNodes[0] #At the moment a child can only have one parent
    
    def getServerHost(self):
        return self.conf['server_host'].get()
    def getClientHost(self):
        return self.conf['client_host'].get()
    def getServerPort(self):        
        return int(self.conf['server_port'].get())
    def getClientPort(self):
        return int(self.conf['client_port'].get())
    def getHostName(self):
        return self.hostname
    
    def getDefaultServer(self):
        return self.conf['client_host'].get()

    def getParentNodes(self):
        return self.conf['parent_nodes'].get()

    def getChildNodes(self):
        return self.conf['child_nodes'].get()
    
    def getMode(self):
        return self.conf['mode'].get()

    def getProjectFile(self):
        return self.getFile('project_file')

    #def getRunBasedir(self):
    #    return self.getFile('project_file')

    def getRunDir(self):
        return self.getFile('run_dir')
    def getExecutablesPath(self):
        lst=self.conf['executables_path'].get().split(':')
        retlist=[]
        for ls in lst:
            str=ls.strip()
            if str != "":
                retlist.append(str)
        retlist.append(self.getFile('global_executables_dir'))
        retlist.append(self.getFile('local_executables_dir'))
        ppath=self.getPluginPaths()
        for p in ppath:
            retlist.append(os.path.join(p, "executables"))
        return retlist
    
    def getCaDir(self):
        return self.getFile('ca_dir')
    
    def getServerKeyDir(self):
        return self.getFile('server_key_dir')
    
    def getServerCertDir(self):
        return self.getFile('server_cert_dir')
    
    def getCertFile(self):
        return self.getFile('cert_file')
    
    def getCertRequestFile(self):
        return self.getFile('cert_request_file')
    
    def getCaChainFile(self):
        return self.getFile('cachain_file')
    
    def getCaConfTemplate(self):
        #a String template, no a real config parameter        
        return cpc.util.ca_conf_template.caConfTemplate   
        
    def getPublicKey(self):
        return self.getFile('pub_key_file')
        
    def getPrivateKey(self):   
        return self.getFile('priv_key_file')

    def getServerSerialFile(self):
        return self.getFile('server_serial_file')

    def getServerIndexFile(self):
        return self.getFile('server_index_file')
    
    def getCaConfigFile(self):        
        return self.getFile('caconf_file')

    def getWebRootPath(self):        
        return os.path.join(self.execBasedir,self.get('web_root'))


